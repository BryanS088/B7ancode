#include <HCSR04.h>
#include <Pixy2.h>

// Pines del motor
int MotorPin1 = 3; // control with the l298n
int MotorPin2 = 2;

// Pines de los sensores ultrasonicos
int LeftSensorPinTrig =  9;
int LeftSensorPinEcho =  8;
int RightSensorPinTrig =  5;
int RightSensorPinEcho =  4;
int FrontSensorPinTrig =  7;
int FrontSensorPinEcho =  6; 

// Pin del botón
int ButtonPin = A0;

// Rango máximo de los ultrasonicos
int FrontDistanceRange = 35;
int LeftDistanceRange = 50;
int RightDistanceRange = 50;

// Rotación del servo
int LeftServoRotation = 800;
int RightServoRotation = 0;
int CenterServoRotation = 500;

// Firma de color para la cámara Pixy
int RedColorSignature = 1;
int GreenColorSignature = 2;

// Pines del encoder rotativo
int EncoderPinA = A1;
int EncoderPinB = A2;
volatile long pulseCount = 0; // Cuenta de pulsos
const int ppr = 360; // Pulsos por revolución
const float wheelDiameter = 0.1; // Diámetro de la rueda en metros

bool BotInRotation = false;
bool ButtonPressed = false;
bool BrickDetected = false;
bool BotStop = false;

bool Debug = true;

HCSR04 LeftSensor (LeftSensorPinTrig, LeftSensorPinEcho);
HCSR04 RightSensor (RightSensorPinTrig, RightSensorPinEcho);
HCSR04 FrontSensor (FrontSensorPinTrig, FrontSensorPinEcho);

Pixy2 pixy;

void MotorForward() {
  digitalWrite(MotorPin1, HIGH);
  digitalWrite(MotorPin2, LOW);
}

void MotorBackward() {
  digitalWrite(MotorPin1, LOW);
  digitalWrite(MotorPin2, HIGH);
}

void ServoRotation(int Angle) 
{
  if (!BotInRotation) {
    pixy.setServos(0, CenterServoRotation);
  }
  pixy.setServos(0, Angle);
}

void AddPulse() {
  pulseCount++;
}

// Función para calcular la distancia recorrida
float calculateDistance(long pulses, int ppr, float wheelDiameter) {
  float circumference = 3.14159265358979323846 * wheelDiameter;
  float distancePerPulse = circumference / ppr;
  return distancePerPulse * pulses;
}

void setup() {
  Serial.begin(9600);
  Serial.println("Setup Working");
  
  pinMode(MotorPin1, OUTPUT);
  pinMode(MotorPin2, OUTPUT);
  pinMode(ButtonPin, INPUT);

  pinMode(EncoderPinA, INPUT_PULLUP);
  pinMode(EncoderPinB, INPUT_PULLUP);
 
  attachInterrupt(digitalPinToInterrupt(EncoderPinA), AddPulse, CHANGE);

  Serial.println("Initializing Pixy2...");
  int pixyInitStatus = pixy.init();
  if (pixyInitStatus != 0) {
    Serial.print("Pixy2 initialization failed with code: ");
    Serial.println(pixyInitStatus);
  } else {
    Serial.println("Pixy2 initialized successfully");
  }
  
  Serial.println("Setup Complete");
  ServoRotation(CenterServoRotation);
}

void loop() {
  if (BotStop) {
    return;
  }

  if (!ButtonPressed) {
    int buttonState = analogRead(ButtonPin);
    delay(50); // debounce delay
    if (buttonState == LOW) {
      ButtonPressed = true;
      Serial.println("Button Pressed");
    }
  }

  int FrontDistance = FrontSensor.dist();
  int LeftDistance = LeftSensor.dist();
  int RightDistance = RightSensor.dist();

  bool RedBlockDetected = false;
  bool GreenBlockDetected = false;

  pixy.ccc.getBlocks();
  if (pixy.ccc.numBlocks) {
    for (int i = 0; i < pixy.ccc.numBlocks; i++) {
      if (pixy.ccc.blocks[i].m_signature == RedColorSignature) {
        RedBlockDetected = true;
      } else if (pixy.ccc.blocks[i].m_signature == GreenColorSignature) {
        GreenBlockDetected = true;
      }
    }
  }

  if (Debug) {
    Serial.print("Front Distance: ");
    Serial.println(FrontDistance);
    Serial.print("Left Distance: ");
    Serial.println(LeftDistance);
    Serial.print("Right Distance: ");
    Serial.println(RightDistance);
  }

  if (RedBlockDetected || GreenBlockDetected) {
    if (RedBlockDetected && !BotInRotation) {
      ServoRotation(RightServoRotation);
      if (Debug) {
        Serial.println("Red Block Detected: Rotating Right");
      }
    } else if (GreenBlockDetected && !BotInRotation) {
      ServoRotation(LeftServoRotation);
      if (Debug) {
        Serial.println("Green Block Detected: Rotating Left");
      }
    }
    BrickDetected = true;
    BotInRotation = true;
  } else if (FrontDistance <= FrontDistanceRange && FrontDistance > 0) {
    if (BrickDetected) {
       BotInRotation = false;
    }

    if (Debug) {
      Serial.println("Obstacle Detected Ahead");
    }
    if (LeftDistance > RightDistance) {
      BotInRotation = true;
      if (Debug) {
        Serial.println("Turning Left");
      }
      ServoRotation(LeftServoRotation);
    } else if (RightDistance > LeftDistance) {
      BotInRotation = true;
      if (Debug) {
        Serial.println("Turning Right");
      }
      ServoRotation(RightServoRotation);
    }
  } else {
    if (BotInRotation) {
      BotInRotation = false;
      ServoRotation(CenterServoRotation);
      Serial.println("Resuming Forward Motion");
    }
  }
}
      Serial.println("Resuming Forward Motion");
    }
  }
 
}
